/* * Screen-transition-diagram.jsx * * Copyright (c) 2014-2015 Yasutsugu Sasaki * http://2-hats.hateblo.jp * * Released under the MIT License. * http://opensource.org/licenses/mit-license.php */#target "illustrator"$.localize = true;$.locale = null;app.coordinateSystem = CoordinateSystem.DOCUMENTCOORDINATESYSTEM;var myDoc = null;var infoLayer = null;var infoLayerName = "Diagram";var allItems = [];var storyboards = [];var others = [];var eachColumnsMaxWidth = [];var xCoords = [-7000];var cumulativeHeight = 7000;var maxCanvasSize = 7500;var invisibleFrameWidth = 0;var offset = 150;function setColor(r, g, b){  var rgbColor = new RGBColor();  rgbColor.red = r;  rgbColor.green = g;  rgbColor.blue = b;  return rgbColor;}function drawFrame(rect, name){  var frame = infoLayer.pathItems.rectangle(    rect[1] + 2,    rect[0] - 2,    rect[2] - rect[0] + 4,    -(rect[3] - rect[1]) + 4,  );  frame.filled = false;  frame.stroked = true;  frame.strokeWidth = 4;  frame.strokeColor = setColor(0, 0, 0);  var titleTF = infoLayer.textFrames.add();  titleTF.textRange.characterAttributes.fillColor = setColor(0, 0, 0);  titleTF.textRange.characterAttributes.size = 32;  titleTF.contents += name;  titleTF.position = [rect[0], rect[1] + titleTF.height + 5];}function drawLine(parentRect,childRect){  var startPoint = [parentRect[2], parentRect[1] + (parentRect[3] - parentRect[1])/2];  var endPoint = [childRect[0], childRect[1] + (childRect[3] - childRect[1]) /2];  var middleX = startPoint[0] + offset;  var color = setColor(0, 0, 0);  var group = infoLayer.groupItems.add();  var line = group.pathItems.add();  line.filled = false;  line.stroked = true;  line.strokeWidth = 6;  line.strokeColor = color;  line.strokeCap = StrokeCap.BUTTENDCAP;  line.strokeJoin = StrokeJoin.MITERENDJOIN;  line.setEntirePath([startPoint, [middleX, startPoint[1]], [middleX, endPoint[1]], [endPoint[0] - 6, endPoint[1]]]);  var triangle = group.pathItems.add();  triangle.closed = false;  triangle.stroked = true;  triangle.filled = false;  triangle.strokeColor = color;  triangle.strokeWidth = 6;  triangle.setEntirePath ([[endPoint[0] - 26, endPoint[1] + 20],[endPoint[0] - 6, endPoint[1]],[endPoint[0] - 26, endPoint[1] - 20]]);}function analyzeHierarchie(name){  var str = name.match(/<[1-9\-]+>/);  if(str != null){    return str.toString().replace("<","").replace(">","").split("-");  } else {    return [];  }}try {  if (app.documents.length > 0 ) {    myDoc = app.activeDocument;          for(var i = 0, il = myDoc.layers.length; i < il; i++){       if(myDoc.layers[i].name == infoLayerName){        infoLayer = app.activeDocument.layers[i];        infoLayer.locked = false;        break;      }    }      for(var i = 0, pl = myDoc.pageItems.length; i < pl; i++){      var item = myDoc.pageItems[i];      if(item.parent.typename == "Layer"){        allItems.push(item);      }    }      for(var i = 0, al = myDoc.artboards.length; i < al; i++){      var hierarchie = analyzeHierarchie(myDoc.artboards[i].name);              var storyboard = {        hierarchie: hierarchie,        tier: hierarchie.length,        name: myDoc.artboards[i].name,        rect: myDoc.artboards[i].artboardRect,        diff:[],        items:[],        children:[]      };          for(var j = 0, pl = allItems.length; j < pl; j++){        var item = allItems[j];        if((myDoc.artboards[i].artboardRect[0] - offset) < item.geometricBounds[0]          && item.geometricBounds[2] < (myDoc.artboards[i].artboardRect[2] + offset)          && (myDoc.artboards[i].artboardRect[1] + offset) > item.geometricBounds[1]          && item.geometricBounds[3] > (myDoc.artboards[i].artboardRect[3] - offset)){          storyboard.items.push(item);        }      }          if(storyboard.tier>0){        var col = storyboard.tier - 1;                if(typeof storyboards[col] === "undefined"){          storyboards[col] = [];          storyboards[col].push(storyboard);        } else {          storyboards[col].push(storyboard);        }            var width = storyboard.rect[2] - storyboard.rect[0];        if(typeof eachColumnsMaxWidth[col] === "undefined"){          eachColumnsMaxWidth[col] = width;        } else {          if(eachColumnsMaxWidth[col] < width) {            eachColumnsMaxWidth[col] = width;          }        }      } else {        others.push(storyboard);      }    }      if(storyboards.length == 0 ){      throw new Error({en:'There are no artboards added specialized tags. Please add the tags to your artboards.', jp:'画面遷移タグが設定されているアートボードがありません。アートボード名を見直してください。'});    }          for(var i = storyboards.length - 1; 0 < i; i--){      for(var j = 0, il = storyboards[i].length; j < il; j++){        var parentHierarchie = storyboards[i][j].hierarchie.concat();        parentHierarchie.pop();        for(var k = 0, pl = storyboards[i-1].length; k < pl; k++){          var parent = storyboards[i-1][k];          for(var m = 0, hl = parent.tier; m < hl; m++){            if(parent.hierarchie[m] != parentHierarchie[m]){                break;               }            if( m == hl - 1){              if(parent.children.length == 0){                  parent.children.push(storyboards[i][j]);              } else {                for(var n = 0, cl = parent.children.length; n < cl; n++){                  var prevItemLayer = parent.children[n].hierarchie[parent.children[n].tier - 1];                  var thisIiemLayer = storyboards[i][j].hierarchie[parent.children[n].tier - 1];                  if(prevItemLayer == thisIiemLayer){                    throw new Error(parent.children[n].name + {en: ' tag have been used on another artboard. Please check the name of all your artboards.', jp:'と階層が重複している画面があります。構造を観直してください。'});                  } else if(thisIiemLayer < prevItemLayer){                    parent.children.splice(n, "", storyboards[i][j]);                    break;                  } else if(prevItemLayer < thisIiemLayer && n + 1 == cl){                    parent.children.push(storyboards[i][j]);                  }                }              }            }           }        }      }    }      for(var i = 0; i < eachColumnsMaxWidth.length - 1; i++){      xCoords[i + 1] = eachColumnsMaxWidth[i] + offset * 2 + xCoords[i];      invisibleFrameWidth += eachColumnsMaxWidth[i] + offset * 2;    }    invisibleFrameWidth += eachColumnsMaxWidth[eachColumnsMaxWidth.length - 1] + offset;      for(var i = 0; i < storyboards[0].length; i++){      (function (storyboard){        var x = xCoords[storyboard.tier - 1];        var y = cumulativeHeight;                if( 16348 < x || y < -16348){          throw new Error({en:'The artboards will be overflowed from the maximum size of your document.', jp:'アートボードの位置がドキュメントの枠を超えてしまいます。構造を見なおしてください。'});        } else {          storyboard.diff[0] = x - storyboard.rect[0];          storyboard.diff[1] = y - storyboard.rect[1];          storyboard.rect[0] += storyboard.diff[0];          storyboard.rect[1] += storyboard.diff[1];          storyboard.rect[2] += storyboard.diff[0];          storyboard.rect[3] += storyboard.diff[1];        }                if(storyboard.children.length == 0){          cumulativeHeight += (storyboard.rect[3] - storyboard.rect[1]) - offset * 2;        } else {          for(var j = 0; j < storyboard.children.length; j++){            arguments.callee(storyboard.children[j]);           }        }      })(storyboards[0][i]);    }    var x = xCoords[0];    var y = cumulativeHeight - offset * 2;    var maxHeight = 0;    for(var i = 0; i < others.length; i++){      if( maxCanvasSize < x || y < -maxCanvasSize){        throw new Error({en:'The artboards will be overflowed from the maximum size of your document.', jp:'アートボードの位置がドキュメントの枠を超えてしまいます。構造を見なおしてください。'});      } else {        others[i].diff[0] = x - others[i].rect[0];        others[i].diff[1] = y - others[i].rect[1];        others[i].rect[0] += others[i].diff[0];        others[i].rect[1] += others[i].diff[1];        others[i].rect[2] += others[i].diff[0];        others[i].rect[3] += others[i].diff[1];      }        var height = others[i].rect[3] - others[i].rect[1];      if(height < maxHeight){        maxHeight = height;      }            x += others[i].rect[2] - others[i].rect[0] + offset * 2;    }    cumulativeHeight += maxHeight;    if(infoLayer != null){      infoLayer.remove();    }    infoLayer = app.activeDocument.layers.add();    infoLayer.name = infoLayerName;    var tempArtboard = myDoc.artboards.add([0,0,10,-10]);    while(1 < myDoc.artboards.length){      myDoc.artboards.remove(0);    }    for(var i = 0; i < storyboards[0].length; i++){      (function (storyboard, parentRect){        var artboard = myDoc.artboards.add(storyboard.rect);        artboard.name = storyboard.name;        drawFrame(storyboard.rect, storyboard.name);                if(parentRect != null){          drawLine(parentRect, storyboard.rect);        }                for(var k = 0, il = storyboard.items.length; k < il; k++){          storyboard.items[k].position = [            storyboard.items[k].position[0] + storyboard.diff[0],            storyboard.items[k].position[1] + storyboard.diff[1]          ];        }                if(storyboard.children.length != 0){          for(var j = 0; j < storyboard.children.length; j++){            arguments.callee(storyboard.children[j], storyboard.rect);           }        }      })(storyboards[0][i], null);    }    for(var i = 0; i < others.length; i++){      var other = others[i];      var artboard = myDoc.artboards.add(other.rect);      artboard.name = other.name;            drawFrame(other.rect, other.name);            for(var k = 0, il = other.items.length; k < il; k++){        other.items[k].position = [          other.items[k].position[0] + other.diff[0],          other.items[k].position[1] + other.diff[1]        ];      }    }    var invisibleFrame = infoLayer.pathItems.rectangle(      7200,      xCoords[0] - offset,      invisibleFrameWidth + offset,      -(cumulativeHeight - 7200 - offset * 3)    );    invisibleFrame.filled = false;    invisibleFrame.stroked = false;    myDoc.artboards.remove(0);    infoLayer.locked = true;        }  else{    throw new Error({en: "Please open a document", jp:"ドキュメントが開かれていません。"});  }}catch(e) {  alert( e.message, {en: "Warning", jp:"スクリプト警告"}, true);}